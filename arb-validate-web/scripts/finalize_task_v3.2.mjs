import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { execSync, exec } from 'child_process';

// === Helper Functions ===
function printUsage() {
    console.log(`
Usage: node finalize_task.mjs --task_id <ID> --task_dir <DIR> --status <DONE|FAILED> [options]

Options:
  --summary "<text>"       Task summary
  --extra "<file1;file2>"  Additional files to include
  --selftest               Run self-test and exit
`);
}

function getArg(name) {
    const idx = process.argv.indexOf(name);
    if (idx !== -1 && idx + 1 < process.argv.length) return process.argv[idx + 1];
    return null;
}

function fail(msg) {
    console.error(`[Finalizer] ERROR: ${msg}`);
    process.exit(1);
}

function sha256Short(filePath) {
    try {
        const content = fs.readFileSync(filePath);
        return crypto.createHash('sha256').update(content).digest('hex').substring(0, 8);
    } catch (e) {
        return "ERROR";
    }
}

// === Main Logic ===

// 0. Self Test Mode
if (process.argv.includes('--selftest')) {
    console.log("[Finalizer] Running Self-Test...");
    const testId = `SelfTest_${Date.now()}`;
    const testDir = path.join(process.cwd(), `temp_${testId}`);
    
    try {
        if (!fs.existsSync(testDir)) fs.mkdirSync(testDir, { recursive: true });
        fs.writeFileSync(path.join(testDir, `run_${testId}.log`), "Self-test log content");
        fs.writeFileSync(path.join(testDir, "test_file.txt"), "Some content");
        
        // Call ourselves recursively
        const scriptPath = process.argv[1];
        const cmd = `node "${scriptPath}" --task_id ${testId} --task_dir "${testDir}" --status DONE --summary "Self Test"`;
        execSync(cmd, { stdio: 'inherit' });
        
        // Verify
        const bundle = path.join(testDir, `bundle_${testId}.zip`);
        const index = path.join(testDir, `deliverables_index_${testId}.json`);
        
        if (!fs.existsSync(bundle) || !fs.existsSync(index)) {
            throw new Error("Artifacts missing after self-test");
        }
        
        console.log("[Finalizer] Self-Test PASSED.");
        // Cleanup
        try { fs.rmSync(testDir, { recursive: true, force: true }); } catch (e) {}
        process.exit(0);
    } catch (e) {
        console.error("[Finalizer] Self-Test FAILED:", e.message);
        // Cleanup
        try { fs.rmSync(testDir, { recursive: true, force: true }); } catch (e) {}
        process.exit(1);
    }
}

// 1. Parse Args
const taskId = getArg('--task_id');
const taskDir = getArg('--task_dir');
const status = getArg('--status');
const summary = getArg('--summary') || "No summary provided";
const extraFiles = getArg('--extra') ? getArg('--extra').split(';') : [];

if (!taskId || !taskDir || !status) {
    printUsage();
    fail("Missing required arguments");
}

if (!['DONE', 'FAILED'].includes(status)) {
    fail("Status must be DONE or FAILED");
}

if (!fs.existsSync(taskDir)) {
    fail(`Directory not found: ${taskDir}`);
}

console.log(`[Finalizer] Processing Task: ${taskId} in ${taskDir}`);

try {
    // 2. Log File (Ensure at least one log exists)
    const logName = `run_${taskId}.log`;
    const logPath = path.join(taskDir, logName);
    
    // If specific log doesn't exist, try to find any .log file
    if (!fs.existsSync(logPath)) {
        const existingLog = fs.readdirSync(taskDir).find(f => f.endsWith('.log'));
        if (existingLog) {
            fs.copyFileSync(path.join(taskDir, existingLog), logPath);
            console.log(`[Finalizer] Copied ${existingLog} to ${logName}`);
        } else {
            fs.writeFileSync(logPath, `[${new Date().toISOString()}] Generated by Finalizer\nStatus: ${status}\nSummary: ${summary}\n`);
            console.log(`[Finalizer] Created placeholder log: ${logName}`);
        }
    }

    // 3. Notify File
    const notifyName = `notify_${taskId}.txt`;
    const notifyPath = path.join(taskDir, notifyName);
    const notifyContent = `RESULT_READY
task_id: ${taskId}
status: ${status}
local_path: ${taskDir}`;
    fs.writeFileSync(notifyPath, notifyContent);
    console.log(`[Finalizer] Created ${notifyName}`);

    // 4. Result JSON
    const resultName = `result_${taskId}.json`;
    const resultPath = path.join(taskDir, resultName);
    if (!fs.existsSync(resultPath)) {
        const resultData = {
            task_id: taskId,
            version: "2.0",
            status: status,
            started_at: new Date().toISOString(),
            ended_at: new Date().toISOString(),
            parser_mode: "strict",
            commands_total: 0,
            commands_executed: 0,
            retries: 0,
            acceptance_check: [{ command: "finalizer", exit_code: status === 'DONE' ? 0 : 1, output: summary }],
            artifacts: [resultName, notifyName, logName]
        };
        fs.writeFileSync(resultPath, JSON.stringify(resultData, null, 2));
        console.log(`[Finalizer] Created ${resultName}`);
    }

    // 5. Index
    // Gather files to include
    let filesToIndex = fs.readdirSync(taskDir).filter(f => 
        !f.startsWith('bundle_') && // Exclude bundles
        !f.startsWith('deliverables_index_') && // Exclude index (added later)
        fs.statSync(path.join(taskDir, f)).isFile()
    );
    
    // Add extra files (copy them in first)
    for (const extra of extraFiles) {
        if (fs.existsSync(extra)) {
            const dest = path.join(taskDir, path.basename(extra));
            if (!fs.existsSync(dest)) {
                fs.copyFileSync(extra, dest);
                filesToIndex.push(path.basename(dest));
            }
        }
    }

    const indexData = filesToIndex.map(f => ({
        name: f,
        size: fs.statSync(path.join(taskDir, f)).size,
        sha256_short: sha256Short(path.join(taskDir, f))
    }));
    
    const indexName = `deliverables_index_${taskId}.json`;
    const indexPath = path.join(taskDir, indexName);
    fs.writeFileSync(indexPath, JSON.stringify(indexData, null, 2));
    console.log(`[Finalizer] Created ${indexName}`);
    
    // Add index itself to the list of files to zip
    filesToIndex.push(indexName);

    // 6. Bundle ZIP (Powershell)
    const bundleName = `bundle_${taskId}.zip`;
    const bundlePath = path.join(taskDir, bundleName);
    
    // Remove existing bundle if any
    if (fs.existsSync(bundlePath)) fs.unlinkSync(bundlePath);

    // Construct Powershell command
    // Compress-Archive -Path "file1","file2"... -DestinationPath "zip"
    // We need to quote paths carefully
    const pathsToZip = filesToIndex.map(f => `'${path.join(taskDir, f)}'`).join(',');
    const psCommand = `powershell -NoProfile -Command "Compress-Archive -Path ${pathsToZip} -DestinationPath '${bundlePath}' -Force"`;
    
    console.log(`[Finalizer] Zipping ${filesToIndex.length} files...`);
    execSync(psCommand);
    
    if (!fs.existsSync(bundlePath)) {
        fail("Zip generation failed");
    }
    console.log(`[Finalizer] Created ${bundleName}`);

    // 7. Update LATEST.json
    // It's in parent of parent of taskDir usually? 
    // Spec says: E:\polymaket\Github\traeback\results\LATEST.json
    // We try to find it relative to taskDir
    const resultsDir = path.dirname(taskDir); // e.g. traeback/results
    const latestPath = path.join(resultsDir, "LATEST.json");
    
    const latestData = {
        latest_task_id: taskId,
        path: `results/${path.basename(taskDir)}/`, // Ensure relative path format
        updated_at: new Date().toISOString()
    };
    
    fs.writeFileSync(latestPath, JSON.stringify(latestData, null, 2));
    console.log(`[Finalizer] Updated LATEST.json at ${latestPath}`);

    console.log("[Finalizer] SUCCESS");

} catch (e) {
    fail(`Exception: ${e.message}`);
}
