import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import { execSync } from 'child_process';

// === Helper Functions ===
function printUsage() {
    console.log(`
Usage: node finalize_task_v3.4.mjs --task_id <ID> --task_dir <DIR> --status <DONE|FAILED> [options]

Options:
  --summary "<text>"       Task summary
  --extra "<file1;file2>"  Additional files to include
  --mode "<smart_agent|script>"  Execution mode (default: smart_agent)
  --zip "<on|off|auto>"    Zip generation mode (default: off)
  --selftest               Run self-test and exit
`);
}

function getArg(name) {
    const idx = process.argv.indexOf(name);
    if (idx !== -1 && idx + 1 < process.argv.length) return process.argv[idx + 1];
    return null;
}

function fail(msg) {
    console.error(`[Finalizer] ERROR: ${msg}`);
    process.exit(1);
}

function resolveTaskDir(taskId, providedDir) {
    const normalizedProvided = path.normalize(providedDir);
    if (normalizedProvided.endsWith(path.join('results', taskId)) || 
        normalizedProvided.endsWith(path.join('results', taskId) + path.sep)) {
        return providedDir;
    }

    const candidate = path.join(providedDir, 'results', taskId);
    if (fs.existsSync(candidate)) {
        console.log(`[Finalizer] Resolved task_dir => ${candidate} (from ${providedDir})`);
        return candidate;
    }

    console.log(`[Finalizer] Using provided task_dir => ${providedDir} (results/${taskId} not found)`);
    return providedDir;
}

// === Main Logic ===

if (process.argv.includes('--selftest')) {
    console.log("[Finalizer] Internal simple selftest skipped. Use scripts/selftest_finalizer_taskdir_marker_zip_consistency_v3.4.mjs");
    process.exit(0);
}

const taskId = getArg('--task_id');
let taskDirRaw = getArg('--task_dir');
const status = getArg('--status');
const summary = getArg('--summary') || "No summary provided";
const mode = getArg('--mode') || "smart_agent";
const zipMode = getArg('--zip') || "off"; 
const extraFiles = getArg('--extra') ? getArg('--extra').split(';') : [];

if (!taskId || !taskDirRaw || !status) {
    printUsage();
    fail("Missing required arguments");
}

if (!['DONE', 'FAILED'].includes(status)) {
    fail("Status must be DONE or FAILED");
}

if (!fs.existsSync(taskDirRaw)) {
    fail(`Directory not found: ${taskDirRaw}`);
}

const taskDir = resolveTaskDir(taskId, taskDirRaw);

console.log(`[Finalizer] Processing Task: ${taskId} in ${taskDir} (Mode: ${mode}, Zip: ${zipMode})`);

try {
    const logName = `run_${taskId}.log`;
    const logPath = path.join(taskDir, logName);
    let logContent = "";
    let logSource = "none";
    
    const evidencePath = path.join(taskDir, 'evidence.log');
    
    if (fs.existsSync(evidencePath)) {
        console.log(`[Finalizer] Found evidence.log`);
        logContent = fs.readFileSync(evidencePath, 'utf8');
        logSource = "evidence.log";
    } else if (fs.existsSync(logPath)) {
        logContent = fs.readFileSync(logPath, 'utf8');
        logSource = "existing_run_log";
    } else {
        const existingLog = fs.readdirSync(taskDir).find(f => f.endsWith('.log') && f !== 'evidence.log');
        if (existingLog) {
            logContent = fs.readFileSync(path.join(taskDir, existingLog), 'utf8');
            logSource = `aggregated_stdio (${existingLog})`;
        } else {
             logContent = `[${new Date().toISOString()}] Generated by Finalizer v3.4\nStatus: ${status}\nSummary: ${summary}\n`;
             if (mode === 'smart_agent') {
                 logContent += `[${new Date().toISOString()}] SMART_AGENT_HANDOVER_START\n`;
                 if (status === 'DONE') {
                     logContent += `[${new Date().toISOString()}] SMART_AGENT_RESULT_FOUND\n`;
                 }
             }
             logSource = "none (generated)";
        }
    }

    console.log(`[Finalizer] Log source: ${logSource}`);
    fs.writeFileSync(logPath, logContent);
    const finalLogContent = fs.readFileSync(logPath, 'utf8');

    const acceptanceCheck = [];
    let markersDetected = false;
    
    if (mode === 'smart_agent') {
        const hasStart = finalLogContent.includes('SMART_AGENT_HANDOVER_START');
        const hasFound = finalLogContent.includes('SMART_AGENT_RESULT_FOUND');
        markersDetected = hasStart && hasFound;
        acceptanceCheck.push({ item: "Log Marker: Handover Start", pass: hasStart });
        acceptanceCheck.push({ item: "Log Marker: Result Found", pass: hasFound });
        if (!markersDetected) console.warn("[Finalizer] ⚠️ Missing Smart Agent markers in log!");
    } else {
        const hasCmdStart = finalLogContent.includes('CMD_START');
        acceptanceCheck.push({ item: "Log Marker: CMD_START", pass: hasCmdStart });
    }

    acceptanceCheck.push({ item: "Artifacts Generated", pass: true }); 
    acceptanceCheck.push({ item: "Task Success", pass: status !== 'FAILED' });

    const resultName = `result_${taskId}.json`;
    const resultPath = path.join(taskDir, resultName);
    
    let startedAt = new Date().toISOString();
    const cpPath = path.join(taskDir, 'checkpoint.json');
    if (fs.existsSync(cpPath)) {
        try {
            const cp = JSON.parse(fs.readFileSync(cpPath, 'utf8'));
            if (cp.start_time) startedAt = cp.start_time;
        } catch {}
    }

    const commandsExecuted = (finalLogContent.match(/CMD_START/g) || []).length;

    const resultData = {
        task_id: taskId,
        version: "2.0",
        status: status,
        started_at: startedAt,
        ended_at: new Date().toISOString(),
        parser_mode: "strict",
        commands_total: commandsExecuted, 
        commands_executed: commandsExecuted,
        retries: 0,
        acceptance_check: acceptanceCheck,
        markers_detected: markersDetected,
        zip_disabled: true,
        zip_requested: zipMode,
        zip_generated: false,
        artifacts: {
            result_json: resultName,
            notify_txt: `notify_${taskId}.txt`,
            latest_json: "LATEST.json"
        }
    };
    
    if (status === 'FAILED') resultData.error = summary;

    const notifyName = `notify_${taskId}.txt`;
    const notifyPath = path.join(taskDir, notifyName);
    const notifyContent = `RESULT_READY
task_id: ${taskId}
status: ${status}
local_path: ${taskDir}`;
    fs.writeFileSync(notifyPath, notifyContent);

    for (const extra of extraFiles) {
        if (fs.existsSync(extra)) {
            const dest = path.join(taskDir, path.basename(extra));
            if (!fs.existsSync(dest)) fs.copyFileSync(extra, dest);
        }
    }

    let filesToIndex = fs.readdirSync(taskDir).filter(f => 
        !f.startsWith('bundle_') && 
        !f.startsWith('deliverables_index_') &&
        fs.statSync(path.join(taskDir, f)).isFile()
    );
    
    // Disable Zip Generation
    if (zipMode !== 'off') {
        console.log(`[Finalizer] Zip disabled (deprecated). Ignoring --zip ${zipMode}.`);
    } else {
        console.log("[Finalizer] Zip disabled (default).");
    }

    // Ensure no bundle_zip in index or artifacts
    // Removed bundle adding block

    const indexData = { files: [] };
    for (const f of filesToIndex) {
        const p = path.join(taskDir, f);
        const s = fs.statSync(p);
        const b = fs.readFileSync(p);
        const h = crypto.createHash('sha256').update(b).digest('hex').substring(0, 8);
        indexData.files.push({ name: f, size: s.size, sha256_short: h });
    }
    
    const indexName = `deliverables_index_${taskId}.json`;
    const indexPath = path.join(taskDir, indexName);
    fs.writeFileSync(indexPath, JSON.stringify(indexData, null, 2));
    
    fs.writeFileSync(resultPath, JSON.stringify(resultData, null, 2));
    console.log(`[Finalizer] Created ${resultName}`);

    const resultsDir = path.dirname(taskDir);
    const latestPath = path.join(resultsDir, "LATEST.json");
    const latestData = {
        latest_task_id: taskId,
        path: `results/${path.basename(taskDir)}/`,
        updated_at: new Date().toISOString()
    };
    fs.writeFileSync(latestPath, JSON.stringify(latestData, null, 2));
    console.log("[Finalizer] SUCCESS");

} catch (e) {
    fail(`Exception: ${e.message}`);
}
